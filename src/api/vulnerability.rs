use actix_web::{HttpResponse, Responder, post, web};
use utoipa::OpenApi;

use crate::model::{
    RemediationPlanRequest, RemediationPlanResponse, VulnerabilityAssessmentRequest,
    VulnerabilityAssessmentResponse,
};
use crate::service::{RemediationService, VulnerabilityService};

#[derive(OpenApi)]
#[openapi(
    info(
        title = "Trustify DA Agents API",
        version = "0.1.0",
        description = "Trustify DA Agents API"
    ),
    paths(get_vulnerability_assessment, get_remediation_plan),
    components(schemas(
        VulnerabilityAssessmentRequest,
        VulnerabilityAssessmentResponse,
        RemediationPlanRequest,
        RemediationPlanResponse,
        crate::model::TrustedRemediation,
        crate::model::VulnerabilityIntel,
        crate::model::VulnerabilityAssessment,
        crate::model::CveIdentity,
        crate::model::PackageIdentity,
        crate::model::CvssVector,
        crate::model::CvssType,
        crate::model::Scope,
        crate::model::RangeType,
        crate::model::AffectedRange,
        crate::model::FixedRange,
        crate::model::CveReference,
        crate::model::SourceType,
        crate::model::ExploitabilityAssessment,
        crate::model::ExploitabilityStatus,
        crate::model::ExploitCondition,
        crate::model::ClaimCertainty,
        crate::model::ImpactAssessment,
        crate::model::ImpactLevel,
        crate::model::RemediationOption,
        crate::model::RemediationKind,
        crate::model::SourceReference,
        crate::model::TrustLevel,
        crate::model::SourceClaim,
        crate::model::SourceClaimReason,
        crate::model::OverallConfidence,
        crate::model::ConfidenceLevel,
        crate::model::Limitation,
        crate::model::LimitationReason,
        crate::model::RemediationPlan,
        crate::model::RemediationAction,
        crate::model::RemediationInstruction,
        crate::model::InstructionDomain,
    ))
)]
pub struct ApiDoc;

/// Get vulnerability intelligence for a package
#[utoipa::path(
    post,
    path = "/v1/vulnerability/assessment",
    request_body = VulnerabilityAssessmentRequest,
    responses(
        (status = 200, description = "Vulnerability assessment retrieved successfully", body = VulnerabilityAssessmentResponse),
        (status = 400, description = "Invalid request"),
        (status = 500, description = "Internal server error")
    ),
    tag = "vulnerability"
)]
#[post("/v1/vulnerability/assessment")]
pub async fn get_vulnerability_assessment(
    service: web::Data<VulnerabilityService>,
    request: web::Json<VulnerabilityAssessmentRequest>,
) -> impl Responder {
    tracing::info!(
        purl = %request.package,
        cve = %request.cve,
        "Received vulnerability intel request"
    );

    match service
        .get_vulnerability_intel(&request.cve, &request.package)
        .await
    {
        Ok(response) => HttpResponse::Ok().json(VulnerabilityAssessmentResponse {
            assessment: response,
            request_id: uuid::Uuid::new_v4().to_string(),
        }),
        Err(e) => {
            tracing::error!(error = %e, "Failed to get vulnerability intel");
            HttpResponse::NotFound().json(serde_json::json!({
                "error": e.to_string(),
                "request_id": uuid::Uuid::new_v4().to_string()
            }))
        }
    }
}

/// Get remediation plan for a vulnerability
#[utoipa::path(
    post,
    path = "/v1/vulnerability/remediation_plan",
    request_body = RemediationPlanRequest,
    responses(
        (status = 200, description = "Remediation plan generated successfully", body = RemediationPlanResponse),
        (status = 400, description = "Invalid request"),
        (status = 500, description = "Internal server error")
    ),
    tag = "vulnerability"
)]
#[post("/v1/vulnerability/remediation_plan")]
pub async fn get_remediation_plan(
    service: web::Data<RemediationService>,
    request: web::Json<RemediationPlanRequest>,
) -> impl Responder {
    tracing::info!(
        purl = %request.package,
        cve = %request.cve,
        "Received remediation plan request"
    );

    match service.generate_remediation_plan(&request).await {
        Ok((plan, assessment)) => HttpResponse::Ok().json(RemediationPlanResponse {
            plan,
            intel: assessment,
            request_id: uuid::Uuid::new_v4().to_string(),
        }),
        Err(e) => {
            tracing::error!(error = %e, "Failed to generate remediation plan");
            HttpResponse::InternalServerError().json(serde_json::json!({
                "error": e.to_string(),
                "request_id": uuid::Uuid::new_v4().to_string()
            }))
        }
    }
}

/// Configure vulnerability routes
pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(get_vulnerability_assessment)
        .service(get_remediation_plan);
}
