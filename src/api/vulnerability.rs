use actix_web::{HttpResponse, Responder, get, post, web};
use utoipa::OpenApi;

use crate::model::{
    RemediationPlanRequest, RemediationPlanResponse, VulnerabilityIntelRequest,
    VulnerabilityIntelResponse,
};
use crate::service::VulnerabilityService;

#[derive(OpenApi)]
#[openapi(
    info(
        title = "Trustify DA Agents API",
        version = "0.1.0",
        description = "Trustify DA Agents API"
    ),
    paths(get_vulnerability_intel, get_remediation_plan),
    components(schemas(
        VulnerabilityIntelRequest,
        VulnerabilityIntelResponse,
        RemediationPlanRequest,
        RemediationPlanResponse,
        crate::model::VulnerabilityIntel,
        crate::model::CveIdentity,
        crate::model::PackageIdentity,
        crate::model::CvssVector,
        crate::model::CvssType,
        crate::model::Scope,
        crate::model::RangeType,
        crate::model::AffectedRange,
        crate::model::FixedRange,
        crate::model::CveReference,
        crate::model::SourceType,
        crate::model::ExploitabilityAssessment,
        crate::model::ExploitabilityStatus,
        crate::model::ExploitCondition,
        crate::model::ClaimCertainty,
        crate::model::ImpactAssessment,
        crate::model::ImpactLevel,
        crate::model::RemediationOption,
        crate::model::RemediationKind,
        crate::model::SourceReference,
        crate::model::SourceType,
        crate::model::TrustLevel,
        crate::model::SourceClaim,
        crate::model::SourceClaimReason,
        crate::model::OverallConfidence,
        crate::model::ConfidenceLevel,
        crate::model::Limitation,
        crate::model::LimitationReason,
        crate::model::RemediationPlan,
        crate::model::RemediationAction,
        crate::model::RemediationInstruction,
        crate::model::InstructionDomain,
    ))
)]
pub struct ApiDoc;

/// Get vulnerability intelligence for a package
#[utoipa::path(
    post,
    path = "/v1/vulnerability/intel",
    request_body = VulnerabilityIntelRequest,
    responses(
        (status = 200, description = "Vulnerability intel retrieved successfully", body = VulnerabilityIntelResponse),
        (status = 400, description = "Invalid request"),
        (status = 500, description = "Internal server error")
    ),
    tag = "vulnerability"
)]
#[post("/v1/vulnerability/intel")]
pub async fn get_vulnerability_intel(
    service: web::Data<VulnerabilityService>,
    request: web::Json<VulnerabilityIntelRequest>,
) -> impl Responder {
    tracing::info!(
        purl = %request.package,
        cve = %request.cve,
        "Received vulnerability intel request"
    );

    match service.get_vulnerability_intel(&request.cve, &request.package).await {
        Ok(response) => HttpResponse::Ok().json(response),
        Err(e) => {
            tracing::error!(error = %e, "Failed to get vulnerability intel");
            HttpResponse::NotFound().json(serde_json::json!({
                "error": e.to_string(),
                "request_id": uuid::Uuid::new_v4().to_string()
            }))
        }
    }
}

/// Get remediation plan for a vulnerability
#[utoipa::path(
    post,
    path = "/v1/vulnerability/remediation_plan",
    request_body = RemediationPlanRequest,
    responses(
        (status = 200, description = "Remediation plan generated successfully", body = RemediationPlanResponse),
        (status = 400, description = "Invalid request"),
    ),
    tag = "vulnerability"
)]
#[post("/v1/vulnerability/remediation_plan")]
pub async fn get_remediation_plan(request: web::Json<RemediationPlanRequest>) -> impl Responder {
    HttpResponse::NotImplemented().json(serde_json::json!({
    "error": "Not implemented",
    "message": format!("Remediation plan lookup for {} ({}) is not yet implemented", request.cve, request.package),
    "request_id": uuid::Uuid::new_v4().to_string()
  }))
}

/// Serve OpenAPI JSON specification
#[get("/openapi.json")]
pub async fn openapi_json() -> impl Responder {
    HttpResponse::Ok().json(ApiDoc::openapi())
}

/// Serve OpenAPI YAML specification
#[get("/openapi.yaml")]
pub async fn openapi_yaml() -> impl Responder {
    HttpResponse::Ok()
        .content_type("text/yaml")
        .body(ApiDoc::openapi().to_yaml().unwrap())
}

/// Configure vulnerability routes
pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(get_vulnerability_intel)
        .service(get_remediation_plan)
        .service(openapi_json)
        .service(openapi_yaml);
}
