use actix_web::{HttpResponse, Responder, post, web};
use utoipa::OpenApi;
use uuid::Uuid;

use crate::api::error::ApiError;
use crate::model::{
    RemediationPlanRequest, RemediationPlanResponse, VulnerabilityAssessmentRequest,
    VulnerabilityAssessmentResponse,
};
use crate::service::{RemediationService, VulnerabilityService};

#[derive(OpenApi)]
#[openapi(
    info(
        title = "Trustify DA Agents API",
        version = "0.1.0",
        description = "Trustify DA Agents API"
    ),
    paths(
        get_vulnerability_assessment,
        get_remediation_plan,
        crate::api::health::liveness,
        crate::api::health::readiness
    ),
    components(schemas(
        VulnerabilityAssessmentRequest,
        VulnerabilityAssessmentResponse,
        RemediationPlanRequest,
        RemediationPlanResponse,
        crate::api::health::HealthStatus,
        crate::api::health::ReadinessStatus,
        crate::api::health::DependencyHealth,
        crate::model::TrustedRemediation,
        crate::model::VulnerabilityIntel,
        crate::model::VulnerabilityAssessment,
        crate::model::CveIdentity,
        crate::model::PackageIdentity,
        crate::model::CvssVector,
        crate::model::CvssType,
        crate::model::Scope,
        crate::model::RangeType,
        crate::model::AffectedRange,
        crate::model::FixedRange,
        crate::model::CveReference,
        crate::model::SourceType,
        crate::model::ExploitabilityAssessment,
        crate::model::ExploitabilityStatus,
        crate::model::ExploitCondition,
        crate::model::ClaimCertainty,
        crate::model::ImpactAssessment,
        crate::model::ImpactLevel,
        crate::model::RemediationOption,
        crate::model::RemediationKind,
        crate::model::SourceReference,
        crate::model::TrustLevel,
        crate::model::SourceClaim,
        crate::model::SourceClaimReason,
        crate::model::OverallConfidence,
        crate::model::ConfidenceLevel,
        crate::model::Limitation,
        crate::model::LimitationReason,
        crate::model::RemediationPlan,
        crate::model::RemediationAction,
        crate::model::RemediationInstruction,
        crate::model::InstructionDomain,
    ))
)]
pub struct ApiDoc;

/// Get vulnerability intelligence for a package
#[utoipa::path(
    post,
    path = "/v1/vulnerability/assessment",
    request_body = VulnerabilityAssessmentRequest,
    responses(
        (status = 200, description = "Vulnerability assessment retrieved successfully", body = VulnerabilityAssessmentResponse),
        (status = 400, description = "Invalid request"),
        (status = 500, description = "Internal server error")
    ),
    tag = "vulnerability"
)]
#[post("/v1/vulnerability/assessment")]
pub async fn get_vulnerability_assessment(
    service: web::Data<VulnerabilityService>,
    request: web::Json<VulnerabilityAssessmentRequest>,
) -> Result<impl Responder, ApiError> {
    tracing::info!(
        purl = %request.package,
        cve = %request.cve,
        "Received vulnerability assessment request"
    );

    let assessment = service
        .get_vulnerability_intel(&request.cve, &request.package)
        .await?;

    Ok(HttpResponse::Ok().json(VulnerabilityAssessmentResponse {
        assessment,
        request_id: Uuid::new_v4().to_string(),
    }))
}

/// Get remediation plan for a vulnerability
#[utoipa::path(
    post,
    path = "/v1/vulnerability/remediation_plan",
    request_body = RemediationPlanRequest,
    responses(
        (status = 200, description = "Remediation plan generated successfully", body = RemediationPlanResponse),
        (status = 400, description = "Invalid request"),
        (status = 500, description = "Internal server error")
    ),
    tag = "vulnerability"
)]
#[post("/v1/vulnerability/remediation_plan")]
pub async fn get_remediation_plan(
    service: web::Data<RemediationService>,
    request: web::Json<RemediationPlanRequest>,
) -> Result<impl Responder, ApiError> {
    tracing::info!(
        purl = %request.package,
        cve = %request.cve,
        "Received remediation plan request"
    );

    let (plan, assessment) = service.generate_remediation_plan(&request).await?;

    Ok(HttpResponse::Ok().json(RemediationPlanResponse {
        plan,
        intel: assessment,
        request_id: Uuid::new_v4().to_string(),
    }))
}

/// Configure vulnerability routes
pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(get_vulnerability_assessment)
        .service(get_remediation_plan);
}
