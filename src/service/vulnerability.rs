use chrono::Utc;
use url::Url;

use crate::model::osv::OsvVulnerability;
use crate::model::{
    extract_versions_from_affected, ClaimCertainty, ConfidenceLevel,
    ExploitabilityAssessment, ExploitabilityStatus, ImpactAssessment, ImpactSeverity,
    OverallConfidence, PackageIdentity, PackageMetadata, VulnerabilityIntel,
};
use crate::service::cache::VulnerabilityCache;
use crate::service::depsdev::DepsDevClient;
use crate::service::document::DocumentService;
use crate::service::osv::OsvError;
use crate::service::OsvClient;

#[derive(Debug, thiserror::Error)]
pub enum VulnerabilityServiceError {
    #[error("Vulnerability not found: {0}")]
    NotFound(String),
    #[error("Internal error: {0}")]
    Internal(String),
}

pub struct VulnerabilityService {
    osv_client: OsvClient,
    depsdev_client: DepsDevClient,
    document_service: DocumentService,
    cache: Option<VulnerabilityCache>,
}

impl VulnerabilityService {
    pub fn new(
        osv_client: OsvClient,
        depsdev_client: DepsDevClient,
        document_service: DocumentService,
        cache: Option<VulnerabilityCache>,
    ) -> Self {
        Self {
            osv_client,
            depsdev_client,
            document_service,
            cache,
        }
    }

    /// Get vulnerability intelligence for a package and CVE
    pub async fn get_vulnerability_intel(
        &self,
        cve: &str,
        package: &PackageIdentity,
    ) -> Result<VulnerabilityIntel, VulnerabilityServiceError> {
        tracing::debug!(
            cve = %cve,
            package = %package,
            "Looking up vulnerability intel"
        );

        let osv_vulnerability = self.get_osv_vulnerability(&cve).await?;
        let cve_identity = osv_vulnerability.clone().into();

        // Extract affected and fixed versions from OSV data
        let purl_str = package.purl.as_str();
        let versions = extract_versions_from_affected(
            &osv_vulnerability.affected,
            Some(package.purl.as_str()),
        );

        // Fetch package metadata from deps.dev (optional - don't fail if unavailable)
        let package_metadata = self.get_package_metadata(purl_str).await;

        // Retrieve and persist reference documents from OSV references
        let reference_urls: Vec<Url> = osv_vulnerability
            .references
            .iter()
            .filter_map(|r| Url::parse(&r.url).ok())
            .collect();

        tracing::debug!(
            cve = %cve,
            reference_count = reference_urls.len(),
            "Retrieving reference documents"
        );

        let reference_ids = self
            .document_service
            .retrieve_and_persist(reference_urls)
            .await;

        tracing::info!(
            cve = %cve,
            retrieved_count = reference_ids.len(),
            "Retrieved reference documents"
        );

        Ok(VulnerabilityIntel {
            cve_identity,
            package_metadata,
            package_identity: package.clone(),
            affected_versions: versions.affected,
            fixed_versions: versions.fixed,
            exploitability: ExploitabilityAssessment {
                status: ExploitabilityStatus::Unknown,
                certainty: ClaimCertainty::Indicative,
                conditions: vec![],
                notes: None,
            },
            impact: ImpactAssessment {
                severity: ImpactSeverity::Unknown,
                confidentiality: None,
                integrity: None,
                availability: None,
                notes: None,
            },
            claims: vec![],
            confidence: OverallConfidence {
                confidence_level: ConfidenceLevel::Low,
                reason: "".to_string(),
            },
            limitations: vec![],
            reference_ids,
            generated_at: Utc::now(),
            retrieved_at: Utc::now(),
        })
    }

    async fn get_osv_vulnerability(&self, cve: &str) -> Result<OsvVulnerability, VulnerabilityServiceError> {
        // Try to get from cache first
        if let Some(ref cache) = self.cache {
            match cache.get_vulnerability::<OsvVulnerability>(cve).await {
                Ok(cached) => {
                    tracing::debug!(cve = %cve, "Cache hit for vulnerability");
                    return Ok(cached);
                }
                Err(e) => {
                    tracing::debug!(cve = %cve, error = %e, "Cache miss or error");
                }
            }
        }

        // Fetch from OSV API
        let osv_vulnerability = self.osv_client.get_vulnerability(cve).await.map_err(|e| match e {
            OsvError::NotFound(id) => VulnerabilityServiceError::NotFound(id),
            OsvError::HttpError(err) => VulnerabilityServiceError::Internal(err.to_string()),
            OsvError::ParseError(msg) => VulnerabilityServiceError::Internal(msg),
        })?;

        if osv_vulnerability.id != cve {
            return Err(VulnerabilityServiceError::NotFound(cve.to_string()));
        }

        // Cache the result
        if let Some(ref cache) = self.cache {
            if let Err(e) = cache.set_vulnerability(cve, &osv_vulnerability).await {
                tracing::warn!(cve = %cve, error = %e, "Failed to cache vulnerability");
            }
        }

        Ok(osv_vulnerability)
    }

    async fn get_package_metadata(&self, purl: &str) -> PackageMetadata {
        // Try to get from cache first
        if let Some(ref cache) = self.cache {
            match cache.get_package::<PackageMetadata>(purl).await {
                Ok(cached) => {
                    tracing::debug!(purl = %purl, "Cache hit for package metadata");
                    return cached;
                }
                Err(e) => {
                    tracing::debug!(purl = %purl, error = %e, "Cache miss or error for package metadata");
                }
            }
        }

        // Fetch from deps.dev API
        let metadata = match self.depsdev_client.get_package_metadata(purl).await {
            Ok(metadata) => metadata,
            Err(e) => {
                tracing::debug!(purl = %purl, error = %e, "Failed to fetch package metadata from deps.dev");
                return PackageMetadata::default();
            }
        };

        // Cache the result
        if let Some(ref cache) = self.cache {
            if let Err(e) = cache.set_package(purl, &metadata).await {
                tracing::warn!(purl = %purl, error = %e, "Failed to cache package metadata");
            }
        }

        metadata
    }
}
