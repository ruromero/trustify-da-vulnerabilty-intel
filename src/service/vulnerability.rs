use std::sync::Arc;

use chrono::Utc;
use url::Url;

use crate::model::osv::{OsvReferenceType, OsvVulnerability};
use crate::model::redhat_csaf::RedHatCsafResponse;
use crate::model::{
    ClaimCertainty, CveIdentity, CveReference, ExploitabilityAssessment, ExploitabilityStatus, ImpactAssessment,
    ImpactSeverity, PackageIdentity, PackageMetadata, SourceType, VulnerabilityIntel,
    extract_versions_from_affected, ExtractedVersions,
};
use crate::service::OsvClient;
use crate::service::assessment::VulnerabilityAssessmentService;
use crate::service::cache::VulnerabilityCache;
use crate::service::cache_keys::generate_assessment_cache_key;
use crate::service::claims::ClaimExtractionService;
use crate::service::depsdev::DepsDevClient;
use crate::service::document::DocumentService;
use crate::service::osv::OsvError;
use crate::service::reference_selector::{max_reference_docs, prioritize_and_limit};
use crate::service::redhat_csaf::RedHatCsafClient;

#[derive(Debug, thiserror::Error)]
#[non_exhaustive]
pub enum VulnerabilityServiceError {
    #[error("Vulnerability not found: {0}")]
    NotFound(String),
    #[error("Internal error: {0}")]
    Internal(String),
}

pub struct VulnerabilityService {
    osv_client: OsvClient,
    depsdev_client: DepsDevClient,
    csaf_client: RedHatCsafClient,
    document_service: Arc<DocumentService>,
    claim_extraction_service: ClaimExtractionService,
    assessment_service: VulnerabilityAssessmentService,
    cache: Option<VulnerabilityCache>,
}

impl VulnerabilityService {
    pub fn new(
        osv_client: OsvClient,
        depsdev_client: DepsDevClient,
        document_service: Arc<DocumentService>,
        claim_extraction_service: ClaimExtractionService,
        assessment_service: VulnerabilityAssessmentService,
        cache: Option<VulnerabilityCache>,
    ) -> Self {
        Self {
            osv_client,
            depsdev_client,
            csaf_client: RedHatCsafClient::new(),
            document_service,
            claim_extraction_service,
            assessment_service,
            cache,
        }
    }

    /// Get the assessment model ID (for cache key generation)
    pub fn assessment_model_id(&self) -> &str {
        self.assessment_service.model_id()
    }

    /// Get vulnerability assessment for a package and CVE
    pub async fn get_vulnerability_intel(
        &self,
        cve: &str,
        package: &PackageIdentity,
    ) -> Result<crate::model::VulnerabilityAssessment, VulnerabilityServiceError> {
        tracing::debug!(
            cve = %cve,
            package = %package,
            "Looking up vulnerability intel"
        );

        // Fetch OSV and Red Hat CSAF data in parallel
        let (osv_result, csaf_result) = tokio::join!(
            self.get_osv_vulnerability(cve),
            self.get_redhat_csaf_vuln(cve)
        );

        // Check if we have data from either source
        let osv_vulnerability = match osv_result {
            Ok(vuln) => Some(vuln),
            Err(VulnerabilityServiceError::NotFound(_)) => {
                tracing::debug!(cve = %cve, "OSV returned NotFound, checking Red Hat CSAF");
                None
            }
            Err(e) => {
                tracing::warn!(cve = %cve, error = %e, "OSV lookup failed with non-NotFound error");
                None // Continue to check CSAF
            }
        };

        let csaf_response = csaf_result;

        // If neither OSV nor CSAF has data, return NotFound
        let has_osv_data = osv_vulnerability.is_some();
        let has_csaf_data = !csaf_response.references.is_empty() || !csaf_response.remediations.is_empty();

        if !has_osv_data && !has_csaf_data {
            tracing::warn!(
                cve = %cve,
                "Vulnerability not found in OSV or Red Hat CSAF"
            );
            return Err(VulnerabilityServiceError::NotFound(cve.to_string()));
        }

        // Create CVE identity from OSV if available, otherwise create minimal from CSAF
        let mut cve_identity = if let Some(ref osv_vuln) = osv_vulnerability {
            osv_vuln.clone().into()
        } else {
            // Create minimal CVE identity from CSAF data
            tracing::debug!(cve = %cve, "Creating CVE identity from Red Hat CSAF data only");
            CveIdentity {
                cve: cve.to_string(),
                description: String::new(), // No description from CSAF alone
                aliases: vec![],
                cvss_vectors: vec![],
                references: vec![],
                published: Utc::now(), // Use current time as fallback
                last_modified: Utc::now(),
            }
        };

        // Extract affected and fixed versions from OSV data (if available)
        let purl_str = package.purl.as_str();
        let versions = if let Some(ref osv_vuln) = osv_vulnerability {
            extract_versions_from_affected(
                &osv_vuln.affected,
                Some(package.purl.as_str()),
            )
        } else {
            // No version data available without OSV
            ExtractedVersions {
                affected: vec![],
                fixed: vec![],
            }
        };

        // Fetch package metadata from deps.dev (optional - don't fail if unavailable)
        let package_metadata = self.get_package_metadata(purl_str).await;

        // Collect references from OSV (with type for prioritization) and CSAF
        let osv_refs_with_type: Vec<(Url, OsvReferenceType)> =
            if let Some(ref osv_vuln) = osv_vulnerability {
                osv_vuln
                    .references
                    .iter()
                    .filter_map(|r| Url::parse(&r.url).ok().map(|u| (u, r.ref_type.clone())))
                    .collect()
            } else {
                vec![]
            };
        let csaf_urls: Vec<Url> = csaf_response
            .references
            .iter()
            .map(|r| r.url.clone())
            .collect();

        // Add all CSAF references to cve_identity.references (for display)
        self.merge_csaf_references(&mut cve_identity, &csaf_response);

        // Prioritize by ref type (Advisory, Fix first) and domain (GitHub, NVD, CVE.org, Red Hat), then cap
        let max_docs = max_reference_docs();
        let reference_urls =
            prioritize_and_limit(osv_refs_with_type, csaf_urls, max_docs);

        // Record when data was retrieved from external APIs
        let retrieved_at = Utc::now();

        tracing::debug!(
            cve = %cve,
            reference_count = reference_urls.len(),
            max_docs = max_docs,
            "Retrieving reference documents (prioritized and capped)"
        );

        let reference_ids = self
            .document_service
            .retrieve_and_persist(reference_urls)
            .await;

        tracing::info!(
            cve = %cve,
            retrieved_count = reference_ids.len(),
            vendor_remediation_count = csaf_response.remediations.len(),
            "Retrieved reference documents"
        );

        // Extract claims from documents using LLM (fetches documents on-demand, cache-first)
        let claims = self
            .claim_extraction_service
            .extract_claims_from_ids(cve, &reference_ids)
            .await;

        // Build VulnerabilityIntel with static data and claims (no placeholders)
        let intel = VulnerabilityIntel {
            cve_identity,
            package_metadata,
            package_identity: package.clone(),
            affected_versions: versions.affected,
            fixed_versions: versions.fixed,
            vendor_remediations: csaf_response.remediations,
            claims,
            reference_ids,
        };

        // Generate cache key for assessment
        let model_id = self.assessment_service.model_id();
        let cache_key = generate_assessment_cache_key(cve, &intel, model_id);

        // Try to get from cache first
        if let Some(ref cache) = self.cache {
            match cache.get_assessment::<crate::model::VulnerabilityAssessment>(&cache_key).await {
                Ok(cached_assessment) => {
                    tracing::debug!(cve = %cve, cache_key = %cache_key, "Cache hit for vulnerability assessment");
                    return Ok(cached_assessment);
                }
                Err(crate::service::cache::CacheError::Miss(_)) => {
                    tracing::debug!(cve = %cve, cache_key = %cache_key, "Cache miss for vulnerability assessment");
                }
                Err(e) => {
                    tracing::warn!(cve = %cve, error = %e, "Cache error for vulnerability assessment, continuing with generation");
                }
            }
        }

        // Assess exploitability, impact, and limitations using LLM
        let (exploitability, impact, limitations) = match self
            .assessment_service
            .assess_vulnerability(cve, &intel)
            .await
        {
            Ok(assessment) => assessment,
            Err(e) => {
                tracing::warn!(
                    cve = %cve,
                    error = %e,
                    "Failed to assess vulnerability, using defaults"
                );
                (
                    ExploitabilityAssessment {
                        status: ExploitabilityStatus::Unknown,
                        certainty: ClaimCertainty::Indicative,
                        conditions: vec![],
                        notes: Some(format!("Assessment failed: {}", e)),
                    },
                    ImpactAssessment {
                        severity: ImpactSeverity::Unknown,
                        confidentiality: None,
                        integrity: None,
                        availability: None,
                        notes: Some(format!("Assessment failed: {}", e)),
                    },
                    vec![],
                )
            }
        };

        // Compute overall confidence based on claims, limitations, and exploitability
        let confidence = self
            .assessment_service
            .compute_confidence(&intel, &exploitability, &limitations)
            .await;

        tracing::info!(
            cve = %cve,
            confidence_level = ?confidence.level,
            "Computed overall confidence"
        );

        // Record when the final assessment was generated
        let generated_at = Utc::now();

        // Build final VulnerabilityAssessment with all real values
        let assessment = crate::model::VulnerabilityAssessment {
            intel,
            exploitability,
            impact,
            confidence,
            limitations,
            generated_at,
            retrieved_at,
        };

        // Cache the assessment
        if let Some(ref cache) = self.cache {
            if let Err(e) = cache.set_assessment(&cache_key, &assessment).await {
                tracing::warn!(cve = %cve, error = %e, "Failed to cache vulnerability assessment");
            } else {
                tracing::debug!(cve = %cve, cache_key = %cache_key, "Cached vulnerability assessment");
            }
        }

        Ok(assessment)
    }

    /// Merge CSAF references into CVE identity (for display). Reference URLs for retrieval
    /// are built separately and limited/prioritized in the main flow.
    fn merge_csaf_references(
        &self,
        cve_identity: &mut crate::model::CveIdentity,
        csaf_response: &RedHatCsafResponse,
    ) {
        for csaf_ref in &csaf_response.references {
            // Map CSAF category to SourceType
            // "self" maps to Advisory (vendor advisory)
            let source_type = match csaf_ref.category.to_lowercase().as_str() {
                "self" => SourceType::Advisory,
                "external" => SourceType::Web,
                _ => SourceType::Advisory, // Default to Advisory for vendor data
            };

            // Add to cve_identity.references if not already present
            if !cve_identity
                .references
                .iter()
                .any(|r| r.url == csaf_ref.url)
            {
                cve_identity.references.push(CveReference {
                    url: csaf_ref.url.clone(),
                    source_type,
                });
            }
        }
    }

    /// Get Red Hat CSAF vulnerability data (with caching)
    async fn get_redhat_csaf_vuln(&self, cve: &str) -> RedHatCsafResponse {
        // Try to get from cache first
        if let Some(ref cache) = self.cache {
            match cache.get_csaf::<RedHatCsafResponse>(cve).await {
                Ok(cached) => {
                    tracing::debug!(cve = %cve, "Cache hit for Red Hat CSAF data");
                    return cached;
                }
                Err(e) => {
                    tracing::debug!(cve = %cve, error = %e, "Cache miss or error for Red Hat CSAF");
                }
            }
        }

        // Fetch from Red Hat CSAF API
        let response = match self.csaf_client.get_vulnerability(cve).await {
            Ok(response) => {
                tracing::debug!(
                    cve = %cve,
                    reference_count = response.references.len(),
                    remediation_count = response.remediations.len(),
                    "Retrieved Red Hat CSAF data"
                );
                response
            }
            Err(e) => {
                tracing::debug!(cve = %cve, error = %e, "Failed to fetch Red Hat CSAF data");
                return RedHatCsafResponse::empty();
            }
        };

        // Cache the result
        if let Some(ref cache) = self.cache {
            // Check if this is new data (cache miss means new data)
            let was_cached = cache.get_csaf::<RedHatCsafResponse>(cve).await.is_ok();
            
            if let Err(e) = cache.set_csaf(cve, &response).await {
                tracing::warn!(cve = %cve, error = %e, "Failed to cache Red Hat CSAF data");
            } else if !was_cached {
                // New CSAF data - invalidate assessments and remediation plans
                if let Err(e) = cache.invalidate_assessments_for_cve(cve).await {
                    tracing::warn!(cve = %cve, error = %e, "Failed to invalidate assessment cache");
                }
                if let Err(e) = cache.invalidate_remediation_plans().await {
                    tracing::warn!(cve = %cve, error = %e, "Failed to invalidate remediation plan cache");
                }
            }
        }

        response
    }

    async fn get_osv_vulnerability(
        &self,
        cve: &str,
    ) -> Result<OsvVulnerability, VulnerabilityServiceError> {
        // Try to get from cache first
        if let Some(ref cache) = self.cache {
            match cache.get_vulnerability::<OsvVulnerability>(cve).await {
                Ok(cached) => {
                    tracing::debug!(cve = %cve, "Cache hit for vulnerability");
                    return Ok(cached);
                }
                Err(e) => {
                    tracing::debug!(cve = %cve, error = %e, "Cache miss or error");
                }
            }
        }

        // Fetch from OSV API
        let osv_vulnerability =
            self.osv_client
                .get_vulnerability(cve)
                .await
                .map_err(|e| match e {
                    OsvError::NotFound(id) => VulnerabilityServiceError::NotFound(id),
                    OsvError::HttpError(err) => {
                        VulnerabilityServiceError::Internal(err.to_string())
                    }
                    OsvError::ParseError(msg) => VulnerabilityServiceError::Internal(msg),
                })?;

        if osv_vulnerability.id != cve {
            return Err(VulnerabilityServiceError::NotFound(cve.to_string()));
        }

        // Cache the result
        if let Some(ref cache) = self.cache {
            // Check if this is new data (cache miss means new data)
            let was_cached = cache.get_vulnerability::<OsvVulnerability>(cve).await.is_ok();
            
            if let Err(e) = cache.set_vulnerability(cve, &osv_vulnerability).await {
                tracing::warn!(cve = %cve, error = %e, "Failed to cache vulnerability");
            } else if !was_cached {
                // New OSV data - invalidate assessments and remediation plans
                if let Err(e) = cache.invalidate_assessments_for_cve(cve).await {
                    tracing::warn!(cve = %cve, error = %e, "Failed to invalidate assessment cache");
                }
                if let Err(e) = cache.invalidate_remediation_plans().await {
                    tracing::warn!(cve = %cve, error = %e, "Failed to invalidate remediation plan cache");
                }
            }
        }

        Ok(osv_vulnerability)
    }

    async fn get_package_metadata(&self, purl: &str) -> PackageMetadata {
        // Try to get from cache first
        if let Some(ref cache) = self.cache {
            match cache.get_package::<PackageMetadata>(purl).await {
                Ok(cached) => {
                    tracing::debug!(purl = %purl, "Cache hit for package metadata");
                    return cached;
                }
                Err(e) => {
                    tracing::debug!(purl = %purl, error = %e, "Cache miss or error for package metadata");
                }
            }
        }

        // Fetch from deps.dev API
        let metadata = match self.depsdev_client.get_package_metadata(purl).await {
            Ok(metadata) => metadata,
            Err(e) => {
                tracing::debug!(purl = %purl, error = %e, "Failed to fetch package metadata from deps.dev");
                return PackageMetadata::default();
            }
        };

        // Cache the result
        if let Some(ref cache) = self.cache
            && let Err(e) = cache.set_package(purl, &metadata).await
        {
            tracing::warn!(purl = %purl, error = %e, "Failed to cache package metadata");
        }

        metadata
    }
}
