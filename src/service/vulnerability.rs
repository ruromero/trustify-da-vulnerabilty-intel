use chrono::Utc;
use url::Url;

use crate::model::osv::OsvVulnerability;
use crate::model::redhat_csaf::RedHatCsafResponse;
use crate::model::{
    extract_versions_from_affected, ClaimCertainty, ConfidenceLevel, CveReference,
    ExploitabilityAssessment, ExploitabilityStatus, ImpactAssessment, ImpactSeverity,
    OverallConfidence, PackageIdentity, PackageMetadata, SourceType, VulnerabilityIntel,
};
use crate::service::cache::VulnerabilityCache;
use crate::service::depsdev::DepsDevClient;
use crate::service::document::DocumentService;
use crate::service::osv::OsvError;
use crate::service::redhat_csaf::RedHatCsafClient;
use crate::service::OsvClient;

#[derive(Debug, thiserror::Error)]
pub enum VulnerabilityServiceError {
    #[error("Vulnerability not found: {0}")]
    NotFound(String),
    #[error("Internal error: {0}")]
    Internal(String),
}

pub struct VulnerabilityService {
    osv_client: OsvClient,
    depsdev_client: DepsDevClient,
    csaf_client: RedHatCsafClient,
    document_service: DocumentService,
    cache: Option<VulnerabilityCache>,
}

impl VulnerabilityService {
    pub fn new(
        osv_client: OsvClient,
        depsdev_client: DepsDevClient,
        document_service: DocumentService,
        cache: Option<VulnerabilityCache>,
    ) -> Self {
        Self {
            osv_client,
            depsdev_client,
            csaf_client: RedHatCsafClient::new(),
            document_service,
            cache,
        }
    }

    /// Get vulnerability intelligence for a package and CVE
    pub async fn get_vulnerability_intel(
        &self,
        cve: &str,
        package: &PackageIdentity,
    ) -> Result<VulnerabilityIntel, VulnerabilityServiceError> {
        tracing::debug!(
            cve = %cve,
            package = %package,
            "Looking up vulnerability intel"
        );

        // Fetch OSV and Red Hat CSAF data in parallel
        let (osv_result, csaf_result) = tokio::join!(
            self.get_osv_vulnerability(cve),
            self.get_redhat_csaf_vuln(cve)
        );

        let osv_vulnerability = osv_result?;
        let csaf_response = csaf_result;
        let mut cve_identity = osv_vulnerability.clone().into();

        // Extract affected and fixed versions from OSV data
        let purl_str = package.purl.as_str();
        let versions = extract_versions_from_affected(
            &osv_vulnerability.affected,
            Some(package.purl.as_str()),
        );

        // Fetch package metadata from deps.dev (optional - don't fail if unavailable)
        let package_metadata = self.get_package_metadata(purl_str).await;

        // Collect reference URLs from OSV
        let mut reference_urls: Vec<Url> = osv_vulnerability
            .references
            .iter()
            .filter_map(|r| Url::parse(&r.url).ok())
            .collect();

        // Add CSAF references to cve_identity.references and reference_urls
        // "self" category maps to Advisory
        self.merge_csaf_references(&mut cve_identity, &csaf_response, &mut reference_urls);

        tracing::debug!(
            cve = %cve,
            reference_count = reference_urls.len(),
            "Retrieving reference documents"
        );

        let reference_ids = self
            .document_service
            .retrieve_and_persist(reference_urls)
            .await;

        tracing::info!(
            cve = %cve,
            retrieved_count = reference_ids.len(),
            vendor_remediation_count = csaf_response.remediations.len(),
            "Retrieved reference documents"
        );

        Ok(VulnerabilityIntel {
            cve_identity,
            package_metadata,
            package_identity: package.clone(),
            affected_versions: versions.affected,
            fixed_versions: versions.fixed,
            vendor_remediations: csaf_response.remediations,
            exploitability: ExploitabilityAssessment {
                status: ExploitabilityStatus::Unknown,
                certainty: ClaimCertainty::Indicative,
                conditions: vec![],
                notes: None,
            },
            impact: ImpactAssessment {
                severity: ImpactSeverity::Unknown,
                confidentiality: None,
                integrity: None,
                availability: None,
                notes: None,
            },
            claims: vec![],
            confidence: OverallConfidence {
                confidence_level: ConfidenceLevel::Low,
                reason: "".to_string(),
            },
            limitations: vec![],
            reference_ids,
            generated_at: Utc::now(),
            retrieved_at: Utc::now(),
        })
    }

    /// Merge CSAF references into CVE identity and reference URLs
    fn merge_csaf_references(
        &self,
        cve_identity: &mut crate::model::CveIdentity,
        csaf_response: &RedHatCsafResponse,
        reference_urls: &mut Vec<Url>,
    ) {
        for csaf_ref in &csaf_response.references {
            // Map CSAF category to SourceType
            // "self" maps to Advisory (vendor advisory)
            let source_type = match csaf_ref.category.to_lowercase().as_str() {
                "self" => SourceType::Advisory,
                "external" => SourceType::Web,
                _ => SourceType::Advisory, // Default to Advisory for vendor data
            };

            // Add to cve_identity.references if not already present
            if !cve_identity.references.iter().any(|r| r.url == csaf_ref.url) {
                cve_identity.references.push(CveReference {
                    url: csaf_ref.url.clone(),
                    source_type,
                });
            }

            // Add to reference_urls for document retrieval if not already present
            if !reference_urls.iter().any(|u| u == &csaf_ref.url) {
                reference_urls.push(csaf_ref.url.clone());
            }
        }
    }

    /// Get Red Hat CSAF vulnerability data (with caching)
    async fn get_redhat_csaf_vuln(&self, cve: &str) -> RedHatCsafResponse {
        // Try to get from cache first
        if let Some(ref cache) = self.cache {
            match cache.get_csaf::<RedHatCsafResponse>(cve).await {
                Ok(cached) => {
                    tracing::debug!(cve = %cve, "Cache hit for Red Hat CSAF data");
                    return cached;
                }
                Err(e) => {
                    tracing::debug!(cve = %cve, error = %e, "Cache miss or error for Red Hat CSAF");
                }
            }
        }

        // Fetch from Red Hat CSAF API
        let response = match self.csaf_client.get_vulnerability(cve).await {
            Ok(response) => {
                tracing::debug!(
                    cve = %cve,
                    reference_count = response.references.len(),
                    remediation_count = response.remediations.len(),
                    "Retrieved Red Hat CSAF data"
                );
                response
            }
            Err(e) => {
                tracing::debug!(cve = %cve, error = %e, "Failed to fetch Red Hat CSAF data");
                return RedHatCsafResponse::empty();
            }
        };

        // Cache the result
        if let Some(ref cache) = self.cache {
            if let Err(e) = cache.set_csaf(cve, &response).await {
                tracing::warn!(cve = %cve, error = %e, "Failed to cache Red Hat CSAF data");
            }
        }

        response
    }

    async fn get_osv_vulnerability(&self, cve: &str) -> Result<OsvVulnerability, VulnerabilityServiceError> {
        // Try to get from cache first
        if let Some(ref cache) = self.cache {
            match cache.get_vulnerability::<OsvVulnerability>(cve).await {
                Ok(cached) => {
                    tracing::debug!(cve = %cve, "Cache hit for vulnerability");
                    return Ok(cached);
                }
                Err(e) => {
                    tracing::debug!(cve = %cve, error = %e, "Cache miss or error");
                }
            }
        }

        // Fetch from OSV API
        let osv_vulnerability = self.osv_client.get_vulnerability(cve).await.map_err(|e| match e {
            OsvError::NotFound(id) => VulnerabilityServiceError::NotFound(id),
            OsvError::HttpError(err) => VulnerabilityServiceError::Internal(err.to_string()),
            OsvError::ParseError(msg) => VulnerabilityServiceError::Internal(msg),
        })?;

        if osv_vulnerability.id != cve {
            return Err(VulnerabilityServiceError::NotFound(cve.to_string()));
        }

        // Cache the result
        if let Some(ref cache) = self.cache {
            if let Err(e) = cache.set_vulnerability(cve, &osv_vulnerability).await {
                tracing::warn!(cve = %cve, error = %e, "Failed to cache vulnerability");
            }
        }

        Ok(osv_vulnerability)
    }

    async fn get_package_metadata(&self, purl: &str) -> PackageMetadata {
        // Try to get from cache first
        if let Some(ref cache) = self.cache {
            match cache.get_package::<PackageMetadata>(purl).await {
                Ok(cached) => {
                    tracing::debug!(purl = %purl, "Cache hit for package metadata");
                    return cached;
                }
                Err(e) => {
                    tracing::debug!(purl = %purl, error = %e, "Cache miss or error for package metadata");
                }
            }
        }

        // Fetch from deps.dev API
        let metadata = match self.depsdev_client.get_package_metadata(purl).await {
            Ok(metadata) => metadata,
            Err(e) => {
                tracing::debug!(purl = %purl, error = %e, "Failed to fetch package metadata from deps.dev");
                return PackageMetadata::default();
            }
        };

        // Cache the result
        if let Some(ref cache) = self.cache {
            if let Err(e) = cache.set_package(purl, &metadata).await {
                tracing::warn!(purl = %purl, error = %e, "Failed to cache package metadata");
            }
        }

        metadata
    }
}
